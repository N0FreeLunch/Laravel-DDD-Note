# 레이어드 아키텍처

```
------------------------------------
|        application layer         |
|   |--------------------------|   |
|   |   infrastructure layer   |   |
|   |  ----------------------  |   |
|   |  |    domain layer    |  |   |
|   |  ----------------------  |   |
|   |--------------------------|   |
------------------------------------
```
- 애플리케이션 레이어 안에 인프라스트럭처 레이어가 존재할 수 있도록 만들고 인프라스트럭처 레이어 안에 도메인 레이어가 존재할 수 있도록 만들어야 한다.
- 애플리케이션 레이어에 대하여 인프라스트럭처 레이어가 캡슐화 되어 있는 것을 알 수 있으며, 인프라스트럭처 레이어에 대해 도메인 레이어가 캡슐화 되어 있다는 것을 알 수 있다.
- 위의 관계는 애플리케이션 레이어가 인프라 레이어 내부로 접근할 수 없고, 인프라스트럭처 레이어가 도메인레이어 내부로 접근할 수 없고 인터페이스에 의존해야 하기 때문에 서로 독립적인 공간이며 분리된 영역을 나타낸다. 그래서 집합적인 포함 관계라고 볼 수 없고 접근의 관계로 봐야 한다. 
- 애플리케이션 레이어에서는 인프라 레이어의 인터페이스를 이용하여 인프라 레이어가 제공하는 기능을 사용할 수 있으며, 인프라 레이어는 도메인 레이어가 제공하는 인터페이스를 이용하여 도메인 레이어가 제공하는 기능을 사용할 수 있는 관계이다.
- 레이어드 아키텍처는 집합적 포함관계 또는 상위 하위 계층의 구조로 보는 것이 아니다.
- 이런 관계로 보면 애플리케이션 레이어는 직접적으로 도메인 레이어의 인터페이스를 활용할 수 없는 레이어를 건너뛰는 것이 허용되지 않는 관계임을 알 수 있다.

## 모듈과 캡슐화
- 모듈은 분할의 단위이다. 이 단위는 기능적인 단위 또는 의미론적 단위에 해당한다. 어떤 의미를 부여해서 모듈을 나누느냐 또는 어떤 기능을 담당하게 해서 모듈을 나누느냐를 생각할 수 있다.
- 예를 들어 기업에는 여러 부서가 존재한다. 부서들의 협동으로 이익을 창출 해 내는데 각 부서는 담당하는 역할이 있다.
- 기업은 각 부서에 어떤 일을 담당해 달라고 말한다. 여러 부서가 각 부서가 맡은 역할을 담당하면 기업의 이익 창출 활동이 이뤄진다. 각 부서에게 어떤 미션을 맡기지만 각 부서는 맡겨진 미션만 이뤄내면 될 뿐, 부서 내에서 누구에게 무엇을 맡기고 일처리를 어떻게 하는지는 기업 전체를 관리하는 입장에서는 생각하지 않아도 되도록 만드는 것이 중요하다. 
- 기업 경영자의 입장에서는 각 부서의 특성에 맡는 미션을 수행하는 것이 인터페이스이고 각 부서의 내부적인 활동은 경영자에게 굳이 보고할 필요가 없다. 이것이 캡슐화이다. 외부에는 특정 미션을 수행하기 위한 인터페이스를 제공하고 외부에 굳이 제공할 필요가 없는 내부 로직은 외부에 제공하지 않고 내부에서 알아서 동작하도록 만드는 것이 캡슐화이다.
- 부서 단위 뿐만 아니라 부품 부서라면 A부품, B부품을 담당하는 영역이 존재하고 A부품과 B부품을 합쳐 하나의 제품을 만드는 것으로 예를 들 수 있다. 제품 단위 등의 다양한 리소스들에 대해 기능적인 단위 의미론적 단위로 구분할 수 있다. 이런 방식을 사용하면 기업-부서 관계 보다 훨씬 작은 단위로 분할을 할 수 있다. 모듈을 더 작게 나눌 수 있는 것이다. 
- 이런 분리의 방식이 도메인 모델을 구축하는 방식이다. 

## 클라이언트
- 어떤 프로그래밍적인 구현이 외부에 인터페이스를 제공할 때, 해당 인터페이스를 활용하는 대상이 클라이언트이다.
- 클라이언트는 ‘클라이언트 – 서버’라는 관계로 보통 설명되지만 인터페이스를 제공할 수 있는 모든 구현을 어떻게든 이용하는 관계로 설명이 되면 클라이언트라고 설명 될 수 있다.

## 계층

### 애플리케이션 계층
- 애플리케이션 계층은 하나의 프로그램의 단위로 인터페이스를 제공하는 계층으로 유저에게 어떤 활용할 수 있는 기능을 제공해 주는 계층이다. 웹 어플리케이션의 프론트와 백앤드는 서로 독립적으로 실행된다. 별도의 프로세스로 실행되기 때문에 백앤드의 클라이언트는 프론트이다. 프론트의 클라이언트는 유저이다. 보통 웹 어플리케이션은 프론트에 HTTP, API, SOAP 프로토콜의 인터페이스를 제공한다. 
- 비즈니스 규칙이나 비즈니스 앤티티에 대한 직접적인 처리를 하는 기능을 포함하지 않는다. 이 구현은 도메인 계층에게 맡긴다.
- 애플리케이션 계층이 인프라 계층을 다루지만, 애플리케이션 계층에서 인프라 계층이 도메인 계층을 어떻게 다루고 있는지 까지 알 필요까지는 없다.

### 애플리케이션 계층에서 담당하는 작업의 예
- 영속성 계층의 트렌젝션 및 보안을 제어(벨리데이션과 같은 기능)한다.
- 이메일과 같은 직접 외부 통신을 하는 기능을 작성
- 이벤트를 제어하고 이벤트에 의한 알람을 다른 시스템으로 보낸다.
- 도메인 계층에서 발생하는 이벤트를 구독한다.
- 애플리케이션 계층은 도메인 모델의 직접적인 클라이언트이다.(? 이건 인프라 계층이 아닌가?)

### 인프라계층이란?
- 도메인 모델을 만들기 위한 다양한 라이브러리 코드 작성의 프레임을 제공하는 공간
- 영속성 계층의 데이터를 다루기 위한 데이터베이스 모델과 같은 기능 및 영속성 계층의 데이터 조작에 관한 기능을 의미론 단위로 모듈화 한 리포지토리 등의 구현이 이뤄지는 영역
- 모델은 인프라 계층의 리포지토리, 모델 등의 다양한 기능이 제공하는 기능의 인터페이스를 받아 구현된다. 이 인터페이스를 받는 방식은 도메인 모델이 가진 객체에 의존성 주입을 통해 이뤄진다.
- 애플리케이션 계층은 인프라계층이 제공하는 인터페이스를 사용하고, 인프라 계층은 도메인 계층이 제공하는 인터페이스를 사용하게 되는데, 도메인 모델이 인프라 계층에서 사용하고 있는 인터페이스를 받아쓰기 위해서 IOC를 통한 의존성 주입 방식을 사용한다. 
- 모델, 리포지토리의 모듈들은 다양한 도메인 모델에서 재사용하게 된다. 인프라계층에서 잘 만들어진 모듈들을 도메인 모델에서 재사용되기 위해서 정의된 모듈들의 객체를 생성하게 되는데 이 구현 방식은 보통 펙토리 패턴을 사용하여 구현한다.

## 제어의 역전 IOC
- 도메인 계층이 인프라 계층에 인터페이스를 제공하고 인프라 계층이 어플리케이션 계층에 인터페이스를 제공하고 어플리케이션 계층이 유저 클라이언트 쪽에 인터페이스를 제공하는데 이 관계가 역전되어 인프라 계층이 도메인 계층에게 인터페이스를 제공할 수 있게 되는 현상을 의미한다.
- 레이어드 아키텍처의 모델에서 애플리케이션 레이어에 인터페이스를 제공하는 레이어가 인프라스트럭처 레이어이며 인프라스트럭처 레이어에 인터페이스를 제공하는 레이어가 도메인 레이어이다. 이 관계를 역전하는 것이 IOC이다. 도메인 레이어는 인프라스트럭처 레이어가 가진 기능들을 활용하여 구현된다. 예를 들어 인프라스트럭처 레이어에는 MVC 모델의 M에 해당하는 영속성 계층의 데이터를 다루기 위한 모델이나 레포지토리를 가지고 있으며 도메인 모델은 이를 가져다가 사용할 수 있다.
- 레이어드 아키텍처의 모델의 개념에 따르면 의존성은 애플리케이션 레이어는 인프라스트럭처 레이어에 의존하여 그 역은 성립되지 않는다. 인프라스트럭처 레이어는 도메인 레이어에 의존하지만 그 역은 성립하지 않는다. 레이어드 아키텍처의 개념에 따르면 도메인 레이어가 인프라스트럭처 레이어에 의존하지는 않지만 인프라 스트럭처의 인터페이스를 사용할 수 있도록 하기 위한 설계를 의미한다. 그래서 의존성 주입을 하여 최대한 결합도를 떨어 뜨리는 것이 핵심이다. 이 부분은 실제 구현에서 객체에 구현되어 있는 인터페이스를 이용하여 코드를 구현해야 하기 때문에 완벽하게 도메인과 독립적인 모델을 만들기 어려울 수도 있다. 이를 돕기 위해 프로그래밍 언어의 interface 키워드를 사용해서 클라이언트와 상호작용할 프로토콜인 인터페이스를 정하는 방식을 사용할 수 있다. (여기서 프로그래밍 언어의 인터페이스와 캡슐화 된 객체의 개념적인 인터페이스는 조금 다르다는 점에 주의 하자. 프로그래밍 언어의 인터페이스 없이도 객체의 인터페이스를 정의할 수 있으며 프로그래밍 언어의 인터페이스는 객체의 인터페이스를 규격화된 형태로 강제하기 위한 방편에 불과하다.)

## 도메인레이어 (+ 모델 레이어)
### 앤티티
- 정보의 단위를 의미한다. 정보는 어떤 구분할 수 있는 속성들이 모여서 하나의 개념적인 단위를 창출한 것을 의미한다. 부품 A, 부품 B, 부품 C가 서로 모여 하나의 제품이 된다고 하자. 그럼 A, B, C는 부품의 속성이며 A, B, C가 서로 모여서 제품이란 단위를 형성을 할 때, 제품이 되면서 A, B, C가 가진 각각의 또는 부분의 속성 만으로는 제품을 올바르게 표현할 수 없는 특징을 가지는 단위가 되는 것이 앤티티의 의미이다.
- 데이터베이스에서는 속성들의 집합이 하나의 레코드가 된다. 이 하나의 레코드가 앤티티를 의미한다.
- OOP에서는 멤버 변수와 멤버 메소드가 하나의 속성을 의미하고 하나의 객체의 멤버 변수와 멤버 메소드가 조합이 되면서 객체만의 어떤 특성을 가지는 것이 앤티티가 되는 것이다.
- 도메인 모델에서 앤티티는 하나의 객체를 의미할 수도 있지만, 모듈화 된 객체들이 모여서 하나의 비즈니스 모델을 형성하는 것을 엔티티라고 부를 수 있다.
- 도메인 모델에서 비즈니스 규칙을 나타낸 한 단위의 비즈니스 로직 또는 하나의 클래스/객체가 비즈니스 앤티티라고 할 수 있다.
- 속성과 속성의 조합으로 속성만으로는 표현할 수 없는 무언가 의미론적 단위를 창출해 내었을 때 이를 앤티티라고 할 수 있다.

### 모델 레이어
- 모델이란 개념은 어플리케이션 분야에 한정해서 다양하게 사용되고 있다. 디비의 데이터 입출력에 관한 기능을 나누어 구조화 하는 것이 MVC 모델에서의 M에 해당하는 모델이다. 또한 애플리케이션에서 개발 영역을 크게 모델, 뷰, 컨트롤러로 나누어 개발하는 것을 MVC 모델이라고 한다. 곧, 모델은 나누는 것을 의미한다. 그리고 나눌 때는 하나의 의미가 드러나거나 한 단위의 기능을 하는 등의 관심사 단위로 나누며 구조화 하여 나누기도 한다. 
- 영속성 계층에 대한 모델이라는 것은 MVC의 M에 해당하고 이 M은 데이터의 입출력을 작은 단위로 나눈 것을 의미한다. 특정 기본키에 해당하는 레코드를 테이블에서 지워라, 특정 기본키에 해당하는 레코드의 특정 값을 수정하라 이런 영속성 계층의 데이터를 조작하는 단위를 만드는 것이다.
- 도메인 모델이란 것은 도메인을 나눈다는 것을 의미한다. 비즈니스 규칙 또는 비즈니스 앤티티에 따라 모듈들을 만들어 나가는 것이 중요하다. 여기서의 모델 레이어라는 것은 도메인 레이어를 의미한다. 도메인 모델인 것이다. 

### 도메인레이어(도메인 모델)의 특징
- 비즈니스 규칙에 관한 로직과 앤티티로 구성됨
- 도메인 모델의 서비스레이어에는 도메인의 특징에 따라 필요한 프로세스 및 작업 처리를 지시한다.
- 도메인 모델의 클라이언트는 애플리케이션 계층에 존재하며 웹 애플리케이션이라면 미들웨어, 컨트롤러, 라우터와 같은 부분이 도메인 모델의 클라이언트가 된다.
- 애플리케이션 계층은 도메인 모델의 처리 결과를 받는다. 웹 애플리케이션이라면 컨트롤러의 리스폰스에 활용할 값을 받을 수도 있고, 특정 도메인 모델이 발생시킨 이벤트의 동작으로 인해서 외부에 알람을 보낼 수도 있는 등 애플리케이션 계층에서 수행해야 할 다양한 동작들을 발생시킬 수 있는, 트리깅 할 수 있는 기능들을 제공한다.
- 애플리케이션이라는 것은 유저가 어떤 처리를 하고 싶어 하는 것이다. 유저가 원하는 특정 인터페이스를 통해 처리 로직이 이뤄진다는 것은 컨텍스트를 형성한다. 이 컨텍스트를 이루기 위해 여러 모듈화된 동작들이 참여하여 한 단위의 비즈니스 로직을 구성한다. 컨텍스트를 나타내는 부분과 모듈화된 동작 단위들은 나눠진다. 이런 컨텍스트와 구성요소의 분리가 도메인 모델의 핵심이다.
- 도메인 모델은 애플리케이션에서 가장 중요한 레이어이다. 왜냐하면 비즈니스 로직을 담당하고 있기 때문이다. 애플리케이션의 다른 계층(데이터를 저장하는 영속성 계층이 포함되지 않는다.)은 도메인 모델을 구성하기 위한 도구들을 제공하는 역할을 하는 것이다.
- 도메인 모델의 개선은 개발자와 도메인 전문가 사이에서 비즈니스가 어떻게 작동하고 기능하는지에 대한 디테일한 논의를 거쳐서 만들어야 한다.

## 서비스 레이어
- 소프트웨어의 존재는 현실 세계의 문제를 해결하기 위해서이다. 현실세계의 문제를 해결하기 위해서는 도메인이 요구하는 문제 해결 방식에 맞는 코드를 만들어야 한다. 시스템을 통제하기 위해서는 도메인 모델과 인프라스트럭처 및 애플리케이션의 영역을 분리해서 코드와 로직이 섞이지 않도록 하는 것이 중요하다. 따라서 거의 모든 애플리케이션은 서비스계층을 구별하여 개발하고 있다.
- 서비스 계층은 보통 코드레벨에서 도메인 계층을 구현한 부분이다. 따라서 서비스 레이어는 시스템의 핵심 비즈니스 규칙에 관한 부분의 로직을 작성하는 부분이다. 서비스 레이어는 도메인의 엔티티를 다루는 작업을 한다. 도메인 모델에서 엔티티가 비즈니스 로직을 나타낸 하나의 단위를 의미하므로 인프라스트럭처의 구성요소가 도메인 모델의 인터페이스를 활용한다는 것은 서비스 레이어의 클래스를 사용하는 것을 보통 의미한다.

## 뚱뚱한 컨트롤러

### 뚱뚱한 컨트롤러란?
컨트롤러 클래스 하나에 너무 많은 코드 및 로직을 작성하는 형태

#### 뚱뚱한 컨트롤러를 사용하면 안 되는 이유
- 프로그래밍의 핵심은 동작하는 코드가 아니라 통제 가능한 코드를 만드는 것이다. 통제 가능한 코드를 만들기 위해서는 캡슐화 되는 단위로 모듈들을 나누고 이 모듈들로 비즈니스 로직을 구성하기 위해 유비쿼터스 언어를 만든다. 이렇게 도메인 모델은 코드를 의미론적으로 나누는 방법을 제시하며, 이렇게 나눠진 코드는 코드의 의미 및 코드 간의 상관관계를 파악하기 쉬워진다.
- 컨트롤러는 클라이언트와의 통신 쓰이는 프로토콜을 서비스 로직이 사용할 수 있도록 변경하는 작업을 하고, 서비스 로직이 만들어 낸 결과를 통신으로 클라이언트에 주기 위한 프로토콜을 만들어 낸다. 이를 컨트롤러의 기본 역할이라고 하자.
- 뚱뚱한 컨트롤러는 컨트롤러의 기본 역할 이외에 서비스 로직이 들어가지도 한다. 서비스 로직이 들어가기도 한다. 서비스 로직을 분리하지 않고 컨트롤러에 넣게 되면 컨트롤러의 코드가 비대해 지고 컨트롤러의 코드를 이해하기 어려워 질 수 있다. 단순히 코드의 이해 뿐만이 아니라 서비스 로직을 캡슐화 하여 컨트롤러의 로직과 분리하는 것이 중요하기 때문에 도메인 계층을 분리하는 것은 필수적이다.

### 얇은 컨트롤러
- 도메인 로직을 컨트롤러에서 분리하고 컨트롤러는 애플리케이션 외부의 클라이언트 요청과 도메인 계층을 이어주는 역할을 하는 코드만 작성하는 것이 컨트롤러를 얇게 만드는 것이다.
- 물론 컨트롤러의 애플리케이션 외부 요청과 응답에 대한 처리 로직이 무척 단순한 형태 또는 서비스 로직이 무척 단순한 형태라면 서비스로직을 분리하지 않을 수도 있지만 단순한 형태라고 하더라도 도메인 모델의 컨텍스트를 활용하는 처리를 하는 경우 서비스 계층의 인터페이스를 사용하는 편이 적절할 수 있다.

