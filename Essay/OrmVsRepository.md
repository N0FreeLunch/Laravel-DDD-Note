## ORM과 레포지토리

### 컴파일 언어와 인터프리터 언어

최근의 웹은 바퀴를 새로 만들지 않기 위해서 웹 프레임워크라는 툴을 이용해 개발한다. 인터프리터 언어가 무언가를 개발하고 실행을 할 때, 웹 프레임워크를 기동해서 어떤 기능의 동작을 확인하기 쉽지만, 컴파일언어는 작성된 코드의 실행을 확인하기 위해 프레임워크를 기동하기 위해서는 작성한 코드와 더불어 프레임워크의 코드도 함께 컴파일을 해야 하므로 동작을 확인하는데 더 오랜 시간이 소요된다.

### 고전파와 런던파

프로그래밍에서 테스트 코드를 작성하는 방법은 크게 두 가지 방식으로 이뤄지는데, 실제 환경과 최대한 유사한 환경에서 코드의 동작을 체크하는 고전파의 테스트 방식으로 불리는 것이 있고, 실제 환경과 유사한 모의 환경에서 직접 데이터를 받아 오지 않고, 객체나 함수가 마치 데이터를 받아 온 것 처럼 가짜 값을 멤버에 저장하거나 반환 값으로 전달하도록 만드는 런던파의 테스트 방식이 있다.

### 고전파의 테스트 방식

실제 환경과 최대한 동일한 환경에서 테스트 코드를 동작시키기 위해서는 작성한 코드 뿐만 아니라, 사용하고 있는 라이브러리와 프레임워크의 코드도 함께 실행해야 한다. 어떤 코드를 작성하고 코드의 동작을 실행하기 위해서 프레임워크와 작성된 코드를 모두 빌드하는 것은 많은 시간이 걸린다. 실제 코드를 개발할 때는 동작을 확인하는 과정이 반복되는데 코드의 실행 시간에 수십초의 시간이 걸리게 되면 그 만큼 생산성이 떨어지게 된다.

고전파의 테스트 방식은 컴파일 언어 보다는 인터프리터 언어를 사용할 때 적절하며, 작성한 코드를 전체 프레임워크가 실행된 상태인 실제 프로덕션 서버의 애플리케이션이 동작하는 코드가 그대로 동작하므로 태스트 코드를 실행할 때 실제 환경과 개발 환경의 차이가 적다는 장점이 있다.

### 런던파의 테스트 방식

모든 코드를 작성하고 실행해서 확인하는 것 보다는, 조금씩 코드를 작성하고 그 결과를 확인해 나가면서 코딩을 하는 것이 일반적이다. 사람은 컴퓨터가 실행하는 모든 코드의 동작을 한 번에 파악하기 어렵고, 프로그래밍 로직의 전개 과정을 놓치는 경우도 있기 때문에 조금씩 코드를 짜고 그 실행 결과가 자신이 의도한 결과를 도출하는지 확인하는 과정이 필요하다. 그렇지 않았을 때 문제가 발생한다면, 어떤 부분에서 문제가 발생했는지 확인하기 어려운 경우가 생길 때가 있다.

컴파일 언어의 경우 조금 작성한 코드의 실행을 확인하기 위해 프레임워크를 포함하는 애플리케이션 전체의 코드를 빌드하는 것은 빌드 시간이 소요되므로 조금 작성한 코드를 계속해서 확인하면서 개발하기 어렵다. IDE에 의존하여 어느 정도의 코드를 만들고 이를 실행하는 방식으로 코드를 작성하는 것을 통해서 점점 더 큰 코드를 작성할 수 있다. 하지만 php와 같은 동적언어는 IDE의 추론이 일어나지 않는 코드도 많고, 화면을 직접 보고 개발해야 하는 경우 화면의 동작이 잘 이뤄지는지 짧은 주기로 확인하는 편이 좋다. 어떤 식으로든 짧은 주기로 작성한 코드를 확인하는 것은 코드 개발에 상당히 유익하다.

빠른 피드벡을 통한 코드의 실행을 확인하기 위해서 컴파일 언어의 경우 조금 작성한 코드의 실행을 확인하기 위해 전체 애플리케이션을 빌드해서 실행하는 것이 아니라, 다른 부분에 의존적인 부분 (프레임워크 또는 외부 데이터에 의존하는 데이터)을 모의하는 것을 통해서 애플리케이션 전체를 빌드하지 않고, 일부만 빌드하여 빠르게 빌드하고 코드의 결과를 확인한다. 컴파일 언어를 사용한 개발에서 특히 TDD는 중요하게 다뤄지는데, 전체적인 기능을 작성하기 전에 로직의 일부만 작성했을 때 그 동작을 확인하는 빠른 피드벡 루프를 사용할 수 있기 때문이다.

### 테스트 가능한 코드 (Testable code)

테스트라는 것은 어떤 인풋 값에 대해 기대할 수 있는 어떤 결과를 얻어 낼 수 있을 때 테스트 가능하다고 한다. 인풋을 어떻게 주었을 때 기대되는 결과는 무엇이다. 이것이 명확해야 테스트를 할 수 있는 코드가 된다.

모든 코드를 테스트 할 수 있는 것이 아니다. 인풋과 아웃풋의 관계가 명확한 코드만 테스트 할 수 있다. 작은 단위의 코드를 테스트하기 위해서는 작은 단위로 인풋에 대한 아웃풋을 확인할 수 있는 코드를 작성해야 한다. 작은 단위의 코드를 작성할 때도 테스트가 가능한 코드를 만들기 위해서는 무엇이 인풋이고 이에 대한 아웃풋은 무엇인지 그 관계를 명확하게 만들어야 테스트가 가능하다.

웹 애플리케이션의 테스트에서 고전파의 테스트 방식으로는 http 리퀘스트를 전달했을 때, http 리스폰스와 데이터베이스의 변경을 확인하면 충분한 경우가 많지만, 애플리케이션을 모두 빌드해서 실행할 수 없는 컴파일 언어의 경우에는 작은 단위로 테스트 가능한 코드를 만들어야 한다.

### 레포지토리 패턴

도메인 주도 설계에서 전술적 패턴은 코딩의 패턴에 대해 알려 준다. 레포지토리 클래스, 엔터티 클래스, DTO 클래스, VO 클래스를 만들고 이들을 사용하여 로직을 구성한다. 특히 레포지토리 패턴은 데이터베이스의 데이터를 가져와서 데이터를 객체 또는 데이터 구조에 담아내는 역할을 한다.

레포지토리의 메소드는 하나의 메소드를 사용하면 데이터베이스에서 데이터를 가져와 객체에 메핑을 할 수 있는 데이터를 담은 객체 또는 객체를 담은 데이터 구조를 제공한다. 이런 레포지토리 패턴은 메소드의 조합으로 다양한 양상이 나오는 것이 아니기 때문에 메소드가 반환할 데이터 객체를 쉽게 모의할 수 있다. 데이터베이스라는 외부 환경에 의존하지 않고, 메소드의 행위를 모의하는 것을 통해서 데이터베이스를 직접 사용하지 않는 코드를 작성할 수 있다.

### 공유 저장소

웹 애플리케이션에서 애플리케이션 서버 자체는 리퀘스트 간의 애플리케이션의 메모리 공유를 하지 않는 stateless 방식으로 만들어진다. 웹 애플리케이션은 스케일 아웃을 할 수 있도록 만들어져야 하는데, 스케일 아웃은 서로 다른 서버에 애플리케이션이 올라가 있는 것이고 서로 간의 데이터 공유가 일어나기 위해서는 애플리케이션 하나에만 데이터 공유가 가능한 메모리에 데이터를 올려 놓을 수 없기 때문에 데이터를 공유할 수 있는 외부 저장소가 필요하다. 이를 위해서 데이터베이스나 Redis 같은 외부 저장소를 사용한다.

### 공유 저장소 테스트의 문제

웹 애플리케이션을 개발할 때, 테스트 코드를 작성하기 위해서는 데이터베이스에서 가져온 정보를 프로그래밍 언어의 데이터 구조에 매핑을 할 필요가 있다. 하지만 테스트 코드를 실행하기 위해서는 데이터베이스에서 데이터를 가져오는 라이브러리를 사용해야 하며, 코드를 조금 작성하고 확인하기 위해서는 라이브러리를 함께 빌드해야 한다. 또는 디비 데이터를 가져오는 라이브러리가 프레임워크에 의존적인 경우 프레임워크를 빌드해야 하므로 빠른 피드백을 이용한 확인이 불가능하다.

테스트 코드를 실행할 때 마다 공유 저장소를 초기화하지 않으면 테스트 코드에서 생성된 데이터가 아닌, 기존 데이터를 이용하므로 코드의 실행 결과가 기대한 양상과 다른 결과를 갖는 경우가 있다. 기존의 데이터가 있더라도 실행한 결과는 인풋에 따라 겨정 되도록 코드를 작성하면 괜찮겠지만, 일반적으로 이를 고려하지 않기 때문에, 테스트 코드를 실행할 때는 데이터 베이스를 초기화한다. 문제는 초기화에 리소스를 많이 소모하기 때문에 속도가 많이 느려 테스트 코드를 실행하는데 적절하지 않다는 문제점이 있다. 따라서 빠른 실행을 할 수 있는 인메모리 디비를 사용한다.

### 인메모리 디비

인메모리 디비를 지원하는 데이터베이스는 코드 실행에 필요한 모든 리소스를 메모리에 올려 mysql과 sqlite가 있다. mysql의 경우 인스톨에 많은 리소스가 필요하기 때문에 테스트용 전용 서버를 구축해야 한다. sqlite의 경우 빠르게 인스톨하고 실행할 수 있기 때문에 테스트용 인메모리 디비로는 sqlite를 주로 사용한다. sqlite는 여러 동시적인 엑세스가 어렵다는 문제점이 있어, 싫제 프로덕션의 데이터베이스로는 사용되지 않는다.

동시 엑세스를 위해 pgsql, mysql, oracle, mariaDB 등을 사용해야 하는데, 이들 데이터베이스의 쿼리와 sqlite의 쿼리는 서로 다르기 때문에 sqlite의 데이터를 다루기 위한 쿼리를 프로덕션용 데이터베이스에 사용할 수 없다는 문제점이 있다. 이 때문에 테스트용 디비로 sqlite를 사용하는 경우에는 한 번 쿼리를 작성하면 여러 데이터베이스에서 사용 가능한 쿼리로 자동으로 바꿔주는 쿼리빌더 또는 ORM이라는 툴을 사용해서 쿼리를 만들어야 한다.

인메모리 디비로 테스트를 할 때 문제점 중 한나는 일반적으로 스키마가 없는 상태에서 마이그레이션 코드를 실행하여 테스트 환경을 구축하는 경우가 많은데, 한 번 테스트를 실행할 때 15초~30초 정도 걸린다는 것이다. 테스트 코드가 실행될 동안, 나머지 코드를 검토하고 전략을 세우면 되기 때문에 해당 시간을 알뜰하게 쓸 수 있지만, 빠르게 확인하지 못하기 때문에 낭비하는 시간이 생긴다고도 볼 수 있다.

### 레포지토리 패턴의 테스트

레포지토리는 데이터베이스에서 데이터를 가져와 프로그래밍 언어의 데이터구조에 데이터를 매핑하는 역할을 한다. 레포지토리의 각각의 메소드는 쿼리를 사용해서 데이터를 가져와서 프로그래밍 언어에 데이터를 매핑한다. 이를 위해서 복잡한 쿼리를 작성하기도 한다. 그러나 raw 쿼리로 레포지토리를 만들게 되면 여러 데이터베이스에서 호환 가능한 쿼리를 만들 수 없기 때문에 테스트용 sqlite 디비를 활용하지 못하는 문제가 있다. 그래서 레포지토리를 만들 때도 쿼리 빌더나 ORM을 사용한 코드를 작성하는 것이 좋다.

레포지토리 패턴을 사용하는데 로우 쿼리로 코드를 작성한다면, sqlite를 사용한 테스트를 사용하지 않는다는 것이며, 이 때 테스트 코드를 작성하기 위해서는 레포지토리를 모의해야 한다. 다양한 모킹 라이브러리를 사용해서 레포지토리의 특정 메소드를 호출했을 때 반환되는 결과를 모의하도록 하자.

### 레포지토리의 코드 구성

로우 쿼리를 사용하면, 각 데이터베이스에서 제공하는 쿼리 최적화를 이용할 수 있다는 장점이 있다. 하지만, 어떤 데이터베이스에서 제공하는 특별한 문법을 사용한 쿼리로 최적화를 할 수록 테스트 디비에서 동일한 동작을 수행하기 위한 쿼리를 작성하므로 두 개의 쿼리를 작성해야 한다. 코드는 검증되어야 하므로 가능한 동일한 코드로 테스트를 수행하는 것이 좋다. 따라서 최적화를 기본적인 코딩 스타일로 사용하기 보다는 꼭 필요한 부분에만 사용하고, 일부러 최적화를 위한 특정 데이터베이스에 의존적인 로직은 피하도록 하자.

물론 테스트 디비를 사용하지 않고 레포지토리가 반환하는 결과를 모의해서 테스트를 작성하는 방식을 사용하면 로우 쿼리로 최적화된 코드를 작성하는 것도 가능하다. 디비에 여러 번 쿼리를 날리는 것이 아니라, 한 번에 필요한 데이터를 최대한 많이 받아오는 방식으로 처리를 하여 통신 횟수를 줄여서 최대한의 응답 속도를 뽑아내기 휘한 애플리케이션에 유용하게 사용할 수 있다.

### 레포지토리의 데이터 매핑

도메인 주도 설계는 어떤 도메인에 필요한 엔터티만을 엔터티 객체가 가지고 있다. 레포지토리 패턴을 사용하여 데이터를 가져올 때 여러 엔터티 간의 관계를 1:1, 1:N, N:M으로 구성 할 수 있다. 데이터베이스의 테이블과 테이블의 관계가 1:1, 1:N, N:M인 것과 동일하게 구성을 할 수도 경우에 따라서는 테이블 간의 관계와 엔터티 간의 관계가 서로 다르게 구성을 할 수도 있다.

### ORM

ORM은 기본적으로 하나의 테이블을 하나의 ORM 객체에 매핑을 한다. 따라서 테이블의 관계와 사용하려는 데이터의 관계가 서로 일치하게 개발할 수 있는 경우 유용하다. 프레임워크를 사용하면 ORM 뿐만 아니라, 테이블의 스키마를 마이그레이션 할 수 있는 툴도 함께 제공되는 경우가 많다. 이를 통해서 테이블의 스키마와 데이터를 마이그레이션하기 어렵지 않기 때문에 원하는 데이터를 ORM에 매핑을 할 수 있다. 물론, 테이블 전체의 데이터가 매핑되기 때문에 필요한 데이터 이상이 매핑되는 문제가 있기는 하지만, 레포지토리 패턴을 구성할 때는 필요한 데이터를 엔터티 객체에 매핑을 해야 했다면, ORM을 이용하면, 쿼리 결과를 객체에 매핑해야 하는 지루한 작업을 줄여주기 때문에 생산성을 높일 수 있는 장점이 있다.

#### 사양패턴

ORM을 이용하면 사양패턴을 활용할 수 있다. 테이블에서 특정 레코드를 추출하기 위해서 사양 패턴을 사용할 수 있으며, 데이터베이스에서 특정 레코드를 추출하기 위해 where을 사용하여 컬럼명과 검색을 위한 키워드를 직접 사용하는 것 보다는, 이를 이루는 메소드를 만들어 도메인 용어로 메소드명을 부여하고, 매개변수의 이름과 타입 설정을 통해서 전달해야 할 값을 표현하여, 도메인 중심적인 표현을 만들어 낼 수 있다.

사양 패턴의 문제는, 여러 메소드를 조합하여 레코드를 취득하는 과정이기 때문에 모의를 통한 테스트하기 어렵다는 단점이 있다. 하나의 객체가 메소드의 조합에 따라 다양한 결과를 갖는다면, 모든 조합에 따른 결과를 모의해야 하는데 이것이 때때로 어려운 경우가 많다. 그래서 모의하는 방식 보다는 실제 데이터베이스를 이용해서 테스트를 구성하는 경우가 많다.

### ORM을 사용하는 이유

레포지토리 패턴을 사용하면, 엔터티와 엔터티의 관계 1:1, 1:N, N:M을 구성해 줘야 한다. 일정 규모 이하의 도메인의 경우에는 테이블의 관계가 곧 엔터티의 관계가 되는 경우가 많은데, ORM을 사용하면 이 작업을 훨씬 단순하게 구성할 수 있다. 테이블과 테이블의 관계를 ORM을 이용해서 쉽게 표현할 수 있기 때문에 레포지토리 패턴을 활용할 때와 같은 쿼리 결과를 엔터티에 매핑을 하는 지루한 작업이 필요하지 않다는 장점이 있다.

### ORM을 사용하지 않는 경우

#### 데이터베이스를 따로 관리하는 경우

ORM은 기본적으로 테이블의 데이터를 객체에 매핑한다. 여러 테이블의 데이터를 하나의 ORM 객체에 담아내지 못한다는 단점이 존재한다. 여러 테이블의 데이터를 종합해서 하나의 엔터티로 표현하는데는 ORM은 적절하지 않다. 특히 sql 전문가가 데이터베이스를 관리하고, 애플리케이션 개발자가 데이터베이스의 스키마를 구성할 수 없을 때는 애플리케이션에서는 원하는 형태의 ORM 객체를 만들 수 없다. 이 때는 레포지토리 패턴을 사용하는 편이 나을 수 있다.

#### 데이터베이스가 제공하는 특별한 기능에 의존하는 경우

스토어드 프로시저와 같은 데이터베이스의 속도를 최대화하거나 뷰 테이블을 사용하는 등의 구성이 필수적으로 요구되는 고속의 디비 엑세스 처리 등이 필요한 분야에서 ORM은 테이블 단위 객체 매핑이기 이므로 적절한 선택이 되지 못한다. 특히, 스토어드 프로시저는 디비에 아주 깊게 종속된 로직으로, 애플리케이션 로직에서 파악할 수 없는 구성이기 때문에 메인테인스하기 어려울 수 있다. 따라서 일반적인 비즈니스가 아닌 특수한 처리를 담당하는 분야에서 이용한다.

### EloquentORM
