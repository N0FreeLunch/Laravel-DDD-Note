# 사양 패턴

사양패턴은, 어떤 대상의 동작을 참 거짓으로 분류하는 방식이다. 진리의 양상을 참, 거짓으로만 판단하고 다른 추가적인 양상은 없다.

어떤 게이트가 있다고 하자. 현재 통과하는 대상은 사람입니까? 예 아니오로 대답할 수 있다. 현재 통과하고 있는 대상은 총을 소지하고 있습니까? 예 아니오로 대답을 할 수 있다. 현재 통과하고 있는 대상은 국가 공무원입니까? 참, 거짓을 판별할 수 있는 조건을 통해서 대상이 어떤 대상인지 특정할 수 있다.

다지선다나 서술형이 아닌, 예 아니오로만 판단할 수 있는 질문을 나열하여, 여러 예, 아니오의 분기문을 거쳐 원하는 조건을 만족하는 대상인지 아닌지 판별하는 방식을 만드는 방식이다.

## 불리언이 중요한 이유

#### 복잡한 로직 설계의 장점

학교 교육에서 사용하는 진리표에 따른 로직의 전개를 따르며, 현존하는 아주 복잡한 시스템들의 근간이 되는 반도체에 논리회로에 쓰일만큼 근본적이고도 단순한 방식으로 복잡한 것을 처리할 수 있는 방식이다.

#### 논리게이트에 의한 설계

논리 게이트는 AND, OR, NOT, NAND, NOR, XOR, XNOR 등의 연산자를 이용해서 로직을 전개하는 방식이다. 사양 패턴을 사용하면, 이런 논리게이트와의 조합을 통해서 로직을 조합할 때 모호함 없이 분명하게 조합할 수 있다는 장점이 있다.

#### 이해의 용이성

하나씩 배제하는 방식을 사용하여 조건이 하나 추가될 때 마다, 부합하지 않는 조건의 대상을 배제하는 방법으로 생각할 수 있기 때문에, 어떤 단계에서 어떤 로직이 처리되는지 파악하기 쉽고, 다수의 조건이 걸쳐 있다고 해도 쉽게 파악할 수 있다.

#### 로직의 명확성

하나의 조건(사양)을 추가할 때 마다, 참 거짓으로 나눠지는 기준이 명확하기 때문에, 조건의 모호함을 줄일 수 있고, 명확한 로직 설계가 가능하다는 장점이 있다.

## 함수형 프로그래밍과 객체지향에서의 사양패턴

함수형 프로그래밍에서는 술어 함수로 사양 패턴을 구현할 수 있으며, 객체지향 프로그래밍에서는 사양을 표현하는 메소드를 통해서 사양 패턴을 구현할 수 있다.

### 함수형 프로그래밍

함수형 프로그래밍은 술어함수라는 참, 거짓의 반환 값을 갖는 함수를 전달하는 것으로 조건에 맞는 대상을 추출하는 방법을 자주 사용한다. 사양 패턴도 마찬가지로 참, 거짓의 두 가지 양상을 통해서 필요한 조건에 맞는 대상을 찾는다.

## 잘 알려진 지식에 기반한 설계 방식

사양 패턴을 사용하지 않는 경우라면 특별한 방법 없이 코드의 논리를 따라가야 하지만, 사양 패턴을 사용하면 필요에 따라 논리 게이트를 구성할 수 있기 때문에, 컴퓨터 공학에서 쓰이는 잘 알려진 지식을 기반으로 시스템의 로직을 설계할 수 있다.

## 도메인 주도 설계

도메인 주도 설계에서 사양 패턴을 사용하면, 하나의 참 거짓을 구분할 수 있는 필터 역할의 함수 및 메소드가 사양이 되며, 이를 통해서 도메인의 제약 조건을 부여할 수 있다.

복잡한 도메인을 사양패턴화 하기 위해서 모호한 표현을 피하고 명확한 참, 거짓으로 분류되는 방식을 통해서 도메인 로직을 좀 더 명확하게 만들 수 있고, 이로 인해서 로직 설계상의 실수를 줄일 수 있다.

## 라라벨

라라벨의 엘로퀀트는 사양페턴을 만들기에 아주 좋은 시스템을 가지고 있는데, or 조건에 해당하는 쿼리 조건을 만들지 않아도 `orWhere(function ($q) { $q->isSomeCondition() })`과 같은 방식으로 로직을 만들 수 있는 편의성을 제공하기 때문이다.

not 조건의 경우에는 `$q->isSomeCondition(excluded: true)`와 같이 명명된 인자를 사용하는 방식으로 메소드를 정의해 주면 된다. `whereNot` 또는 `orWhereNot` 등의 엘로퀀트에서 제공하는 메소드를 사용하는 방법을 쓸 수도 있다. `whereNot(function ($q) { $q->isSomeCondition() })` 이나 `orWhereNot(function ($q) { $q->isSomeCondition() })`을 만들 수 있는 것이다.

NAND, NOR, XOR, XNOR 등의 연산자는 and, or, not 연산자의 조합으로 구현할 수 있기 때문에 없어도 되지만, 필요하다면 커스터마이즈 메소드로 추가하는 것을 고려할 수 있다.
