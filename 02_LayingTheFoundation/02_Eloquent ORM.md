## Eloquent ORM
- 라라벨에서 도메인 중심 디자인을 개발하는 데 가장 중요한 도구 중 하나는 Eloquent이다.

### DDD와 ORM
- 데이터 질의어(Data Definition Language)를 코드를 작성할 때 직접 사용하는 것은 도메인 주도 설계의 내부 관행과 가치에 맞지 않는다. 왜냐하면 DDD는 불가지론적인 방법인데 데이터 정의어를 직접 사용하는 것은 특정 DB등에 종속되는 것이기 때문이다.
- 다양한 데이터베이스에 대한 데이터 조작을 동일한 방식으로 할 수 있는 엑티브 레코드 곧 ORM을 사용하는 것은 디비의 질의어에 종속되지 않기 때문에 DDD에 적합하다.
- 디비 등의 저장소의 데이터를 조작해야 하는 도메인의 이벤트를 허용한다.

### ORM의 장점
- 모델 간의 관계를 생성 및 관리가 편리하다.
- 모델의 생성 및 관리를 편리하게 하여 복잡한 질의어가 아닌 간단한 표현적인 구문을 사용하여 쿼리 처리를 할 수 있다.
- ORM은 데이터를 가져와서 객체에 저장을 하고 있다. 모델을 통해서 업데이트 작업이 일어나면 객체에 데이터를 다시 저장하는 로직이 필요하다. 이러한 작업을 ORM이 자동으로 해 준다.

### Eloquent ORM의 특성
- 대량 할당 (messive assignment)
- 쿼리 스코프
- Eager loading
- 컬렉션
- 모델 이벤트
- 모델 옵저버
- 모델이 유효하고 일관된 상태인지 체크
- 잘못된 사용을 방지하기 위해 적절한 제한이 있는지 확인하는 유효성 검사 구성 요소가 존재

### 객체
- 기본적으로 클래스에는 멤버 변수와 멤버 메소드가 존재한다. 멤버 변수는 객체의 상태를 저장하는 부분이며, 멤버 메서드는 객체의 상태를 변경하기 위한 조작 기능을 정의한 곳이다.
- 기본적으로 객체는 데이터를 저장하는 부분과 데이터의 변경하는 기능을 동시에 가지고 있다. 하지만 현재 프로그래밍에서는 객체의 데이터와 동작을 분리하는 방식을 고안하는 경향이 커졌다.
- 기본적으로는 객체의 멤버를 다루기 위한 getter와 setter가 존재하는 객체로 이해를 한다.

### DTO
- 기본적인 객체의 특성을 가지고 있으면서 데이터를 객체에 매핑한 객체이다. 
- 단순 매핑의 기능을 담당하는 개념을 가진 대상이기 때문에 디비의 데이터를 저장하고 읽고 변경하는 로직만 존재한다.
- DTO를 이해하기 위해서는 영속성 계층에 대한 개념이 있어야 하는데 영속성 계층은 데이터 베이스 등 영구적으로 데이터가 저장되는 계층을 의미한다.
- Data Transfer Object라고 부르는데 영속성 계층의 데이터를 애플리케이션에서 사용하기 위해 임시적으로 저장하는 기능을 한다. 보통은 디비의 데이터를 객체로 다루기 위한 방식으로 이용된다.
- 다량의 쿼리 요청을 방지하기 위해서 영속성 계층에서 데이터를 한 번만 가져와서 DTO에 저장한 다음 저장한 데이터에 대한 getter, setter 등의 동작을 제공하여 잦은 디비 엑세스를 방지하기 위한 용도로 사용된다.
- 영속성 계층의 데이터는 DTO의 멤버 변수에 매핑이 되어 있으며, DTO는 직접적으로 영속성 계층에 데이터를 다루지 않는다.
- 단순히 영속성계층의 데이터를 임시 저장하는 개념이므로 멤버 변수에 대한 특별한 로직이 추가되지 않은 단순한 형태의 getter와 setter를 사용한다. 
- setter는 DTO 객체의 상태 변화를 초래할 뿐 영속성 계층의 데이터에 직접적인 영향을 주지는 않는다.
- DTO 객체는 영속성 계층(데이터 베이스 등 영구적으로 데이터가 저장되는 계층)에서 데이터를 가져와서 멤버에 저장하는 방식으로 사용되므로 데이터의 조작을 정의하는 웹 어플리케이션의 MVC의 모델과는 다른 개념이다.

#### DTO 계층을 만드는 이유
- 한번 가져온 데이터를 여러 번의 엑세스를 하면 될 경우, 매번 쿼리를 사용하여 가져올 필요가 없다. 영속성 계층의 데이터의 변경이 일어나기 전까지는 한번 데이터를 가져와서 저장한 객체에 접근하여 데이터를 가져오면 훨씬 효율적이다.
- 하지만 데이터의 변경이 이뤄지는 경우 이를 감지하여 DTO의 데이터를 리프레시 해 줘야 한다. 라라벨의 Eloquent ORM은 모델 옵저버 기능을 활용해 데이터의 변경이 일어났을 경우, ORM의 데이터를 변경해 주는 기능을 가지고 있다. 하지만 DTO의 경우는 기본적으로 수동으로 리프레시를 해야 한다.

#### 라라벨에서의 DTO
- 라라벨의 Eloquent ORM은 DTO와는 다른 개념이다. 디비의 데이터를 가져오기 위한 제약 및 관계를 만들기 위한 기능 등 실용적인 쓰임을 위해서 만든 것으로 엑티브레코드라는 명칭으로 불린다.
- ORM에서 사용할 수 없는 쿼리의 세부적인 컨트롤 등을 위해서 ORM과 영속성 계층 사이 DTO를 정의하여 쿼리를 세부적으로 컨트롤 하는 인터페이스를 제공하는 객체를 만들 수 있다. 하지만 대개의 경우, ORM이 제공하는 기능을 활용해서 편리하게 레포지토리 인터페이스를 만들 수 있기 때문에 DTO 계층을 따로 만들 필요는 없다.


### Eloquent 모델의 예
```php
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Custormer extends Model
{
  public $table = 'customers';
  protected $fillable = ['name', 'phone', 'phone_type'];
}
```
- `public $table = 'customers';` : customers이라는 이름을 가진 테이블을 엘로퀀트에 매핑한다는 의미이다.
- `protected $fillable = ['name', 'phone', 'phone_type'];` : 엘로퀀트를 통해서 데이터를 가져오는 컬럼은 테이블의 name, phone, phone_type 세 가지 컬럼만 사용하겠다는 의미이다.

```php
<?php
use App\Models\Customer;

$Customer::first();
echo $Customer->phone;
echo $customer->phone_type;
```
- 엘로퀀트 모델을 불러다 쓸 때는 정적 메서드 방식으로 사용한다.
- 데이터를 가져올 때는 '엘로퀀트 컬렉션'의 함수를 사용하여 데이터를 불러 온다.
- 데이터를 불러 왔을 때, 하나의 레코드에 대한 데이터이면 멤버 접근 방식으로 컬럼을 사용할 수 있으며, 배열 형태의 컬렉션이면 배열의 원소 하나에 해당하는 객체에 접근한 후 객체의 멤버로 레코드의 컬럼 값을 접근할 수 있다.
- 컬럼 값 조회 : `$Customer->phone`, `$customer->phone_type`

## 스토어의 원본 데이터를 변환하여 다뤄야 할 때
- 기본적으로 쿼리를 사용하든 엘로퀀트를 사용하든 데이터베이스 안의 데이터를 그대로 보여준다. 하지만 클라이언트 쪽에 데이터를 보여 줄 때는 디비의 데이터를 그대로 보여주는 것이 아니라 가공을 해서 데이터를 보여 주는 경우가 많다. 이 경우 엘로퀀트를 사용하면 엘로퀀트로 데이터를 받아 오는 즉시 변환한 값을 받을 수 있다.

### DTO를 사용하는 경우
- 디비의 데이터를 클라이언트에 보여주기 위한 데이터로 변환하는 작업을 DTO 계층을 통해서 할 수 있다. 데이터 계층의 데이터를 DTO 계층에서 받아서 애플리케이션 계층으로 데이터를 보내기 전에 원본 데이터의 형태를 가공해서 보내주는 방법이다.
- DTO의 구조는 멤버변수와 getter와 setter로 구성되어 있다. 멤버 변수는 원본 데이터를 저장하는 기능을 담당하고 getter와 setter는 어떠한 변환 없이 단순한 데이터를 가져오고 저장하는 역할을 하는 용도로 정의된다. getter에 어떤 추가적인 로직이 들어가는 것이 아니기 때문에 DTO의 멤버에는 영속성 계층에서 받은 데이터를 애플리케이션에서 보여 줘야 할 데이터로 변환한 것을 저장해야 한다.
- DTO에는 애플리케이션 계층에서 사용할 표현의 데이터를 넣어 둔다. 이 경우, 영속성 계층의 데이터와 DTO에 저장된 데이터가 동일한 데이터를 가리킴에도 표현이 다르게 되어 있다. 영속성 계층의 데이터와 다른 표현의 데이터를 DTO에 저장하는 것이 데이터를 2중으로 다루기 때문에 좋은 방식은 아니라고 한다. 엘로퀀트에서는 저장이 아닌 바로 변환하는 방법을 사용하여 좀 더 좋은 형태로 사용하고 있다고 한다.
- 애플리케이션 계층의 데이터를 저장하기 위한 DTO와 영속성 계층의 데이터의 표현이 다르다면 transfomer를 통해서 데이터를 변환하여 전송하는 기능이 필요하다.

### 스키마 설계
- customer_type_name 컬럼의 의 값으로 영희, 철수가 데이터로 들어 있고 각각에 대해 customer_type_id 컬럼의 값으로 1, 2라는 데이터가 들어 있다고 하자.  customer_type_id 1이 영희를 customer_type_id  2가 철수를 지정하는 것이기 때문에 하나의 데이터만 있어도 식별이 되는 대상을 두 데이터를 넣어 만들었다. 보통 이런 경우 테이블을 하나에 두 컬럼을 정의하지 않고 아니라 타입에 관한 테이블을 따로 분리 한다. 그래서 현재 테이블에는 customer_type_id 만 넣고 customer_type이라는 다른 테이블에 id, name을 가진 대상을 넣는다. 따라서 하나의 테이블에 customer_type_name, customer_type_id 두 컬럼을 넣는 것은 동일한 타입을 가진 레코드가 많아지면 많아질수록 customer_type_id와 customer_type_name 그룹을 반복하는 양태를 띤다. 중복 방식으로 데이터를 복제하게 되므로 바람직한 테이블 설계가 아니다.

### 엘로퀀트를 사용하는 경우
- 웹 어플리케이션의 모델이 가지는 역할은 저장소의 데이터를 다루는 방식에 관한 정의를 담고 있다. 영속성 계층의 데이터와 애플리케이션 계층의 데이터를 따로 관리하지 않기 위해서는 영속성 계층의 데이터를 애플리케이션 계층의 데이터로 가져올 때 어떤 엑션을 통해서 변환 해서 가져오는 방식으로 만드는 것이다. DTO의 경우처럼 변환된 데이터를 따로 저장을 하는 방식을 사용하는 것이 아니라, 영속성 계층의 데이터를 애플리케이션 계층으로 저장을 하지 않고 표현의 변환을 하는 방식을 사용한다.
- 영속성 계층의 데이터를 가져올 때 데이터를 애플리케이션 계층에 맞는 표현으로 변환을 하기 위해서 라라벨의 엘로퀀트 모델은 mutators 및 accessors라는 기능을 제공한다.

#### mutators/accessors
- Accessor : get + 컬럼명의 카멜케이스 + Attribute 형식으로 메서드를 정의하면 해당 컬럼명을 엘로퀀트 모델의 멤버 변수 형태로 조회할 때 정의한 메서드의 로직을 거친 결과 값을 얻는다.
- mutator : set + 컬럼명의 카멜케이스 + Attribute 형식으로 메서드를 정의하면 해당 컬럼명을 엘로퀀트 모델의 멤버 변수 형태로 데이터를 저장할 때 정의한 메서드의 로직을 거친 값을 저장한다.
- mutators 와 accessors 메서드는 매개변수로 컬럼의 원본 벨류를 받는다. 그리고 반환 값으로 디비의 원본 데이터를 어떻게 변환해서 엘로퀀트 모델을 통해 나타낼지를 지정한다.

#### example
- name의 첫 글자가 대문자로 변환되어 반환 되도록 만든다.
- phone 타입에 따라 타입 넘버가 아닌 타입에 해당하는 문자열이 출력되도록 만든다.
```php
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Customer extends Model
{
  public $table = 'customers';
  protected $fillable = ['name', 'phone', 'phone_type'];
  
  public function getNameAttribute($name)
  {
    return ucfirst($NAME);
  }
  
  public function getPhoneTypeAttribute($phone_type)
  {
    switch($phone_type) {
      case 1:
        return "home phone";
        break;
      case 2:
        return "cell phone";
        break;
      case 3:
        return "work phone";
        break;
      default:
        throw new Exception("dang!");
    }
  }
}
```
- 엘로퀀트 모델에 접두어(get, set) + 컬럼명의 카멜케이스 + Attribute로 메서드 명을 만들면, 해당 컬럼을 조회할 때 이 메서드의 정의된 로직을 거친 값을 얻게 된다.

```
<?php
use App\Models\Customer;

$customer = Customer::find(2);
echo $customer -> phone_type;
echo $customer -> getAttribute('phone_type');
```
- `$customer -> phone_type`의 결과 값은 `cell phone`
- `$customer -> getAttribute('phone_type');`의 결과 값은 `2`
- 엘로퀀트 모델의 멤버 변수를 직접 호출하게 되면 accessors로 정의된 로직의 결과 값을 얻으며, getAttribute 메서드를 사용하면 디비에 저장된 원본 데이터 값이 나온다.
- accessors를 정의를 하면 디비의 원본 데이터와 다른 값을 얻기 원본 데이터가 어떤 패턴과 룰로 저장되고 있는지 가려져 있다. 이 때문에 데이터를 저장할 때 accessors로 표현된 패턴을 쓰게 되면 raw 데이터에 원본의 패턴과 룰을 무시하고 집어 넣게 될 수 있다. 그래서 accessors를 정의하면 mutators를 사용하여 엘로퀀트 모델로 표현된 데이터의 패턴을 집어 넣더라도 원본 디비의 패턴과 룰에 일치하는 데이터를 넣도록 mutator을 정의해 줘야 한다.

#### DTO와 엘로퀀트 모델
- 영속성 계층의 원본 데이터와 애플리케이션 계층에서 표현되는 데이터를 다르게 표현해야 할 경우, 엘로퀀트 모델의 mutators/accessors를 사용하면 두 계층의 데이터 표현 방식을 분리할 수 있다.
- DTO를 사용하면 원본 데이터를 애플리케이션 계층에서 표현하기 위해 DTO 객체에 애플리케이션 계층에서 표현할 데이터를 집어 넣어야 하는데, 엘로퀀트 모델을 사용하면 이럴 필요가 없다.

### 엘로퀀트 모델의 단점
- DDD는 인프라 레이어와 도메인 레이어를 명확하게 분리하는 것에 초점을 맞추고 있다. 왜냐하면 도메인 레이어를 유비쿼터스 언어로 설명해야 하기 때문이다. 도메인 레이어는 인프라 레이어와 독립적으로 설계가 가능해야 한다는 철학을 가지고 있다.
- 엘로퀀트 모델은 DDD의 철학 일부를 위배하는 설계를 가지고 있다. DTO를 사용할 경우에는 직접적으로 영속성 계층의 데이터를 조작하는 모델과 데이터를 애플리케이션 계층에서 쓰기 위한 DTO를 분리해서 사용을 하는 반면에 엘로퀀트 모델을 사용하면, 엘로퀀트 모델을 통해 직접적으로 데이터를 다루며 엘로퀀트 모델이 주는 결과 값을 애플리케이션 계층에서 사용을 한다. 모델과 DTO를 분리해서 영속성 계층의 데이터와 애플리케이션 계층의 데이터를 완전히 분리한 객체를 다루기 위한 DDD의 모델링과 달리 엘로퀀트 모델은 영속성 계층의 데이터와 애플리케이션 계층의 데이터를 혼합된 방식으로 제공하고 계층의 구분을 불분명하게 만들기 때문에 DDD의 철학을 일부 위배한다. 이것이 라라벨에 DDD를 완벽하게 적용할 수 없는 이유이다.
- 하지만 DDD 모델링 철학의 영속성 계층과 도메인 계층의 완벽한 분리를 이론적인 측면에서 바라보는 것이 아니라 비즈니스적인 문제 해결 측면에서 바라본다면 의미 있게 사용할 수 있다.
